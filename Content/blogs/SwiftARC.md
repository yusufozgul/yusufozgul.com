---
title: Swift ARC
date: 2020-10-28 14:06
tags: Swift, Software
description: Swift programlama dilinde bellek yÃ¶netimi nasÄ±l yapÄ±lÄ±yor, bellek yÃ¶netimi neden Ã¶nemlidir?

---


Bir donanÄ±m Ã¼zerinde Ã§alÄ±ÅŸan yazÄ±lÄ±mlar Ã§alÄ±ÅŸtÄ±klarÄ± sÄ±rada Ã¼zerinde bulunduÄŸu donanÄ±m kaynaklarÄ±nÄ± kullanÄ±rlar. YazÄ±lÄ±mlarÄ±n kullandÄ±ÄŸÄ± kaynaklarÄ±n elbette bir sÄ±nÄ±rlamasÄ± olmalÄ± Ã§Ã¼nkÃ¼ genellikle bir donanÄ±m Ã¼zerinde birden fazla yazÄ±lÄ±m aynÄ± anda Ã§alÄ±ÅŸmakta ve sadece tek donanÄ±mÄ± paylaÅŸmaktadÄ±rlar. Burada en Ã§ok dikkat etmemiz gereken donanÄ±m bellek Ã§Ã¼nkÃ¼ depolama birimleri eÄŸer bir cache mekanizmasÄ± kullanmÄ±yorsak ya da sonradan depolama yapmÄ±yorsak kurulduÄŸu ÅŸekilden Ã§ok fazla artmazlar. Ancak kodumuz Ã§alÄ±ÅŸÄ±rken bellekte yer kaplar ve Ã§alÄ±ÅŸtÄ±ÄŸÄ± sÃ¼re boyunca farklÄ± iÅŸlemler yaparak bellekte daha fazla yere ihtiyaÃ§ duyar aynÄ± zamanda artÄ±k bir daha kullanmayacaÄŸÄ±mÄ±z alanlar oluÅŸur. Kaynaklardan bir diÄŸeri ise CPU. CPU zaten iÅŸletim sisteminin sahip olduÄŸu CPU scheduling algorithms ( CPU zamanlama algoritmalarÄ±) sayesinde her iÅŸleme karÅŸÄ± belirli bir sÄ±nÄ±rÄ±n Ã¼zerinde Ã§alÄ±ÅŸma izni vermemekte, Ã§ok aÄŸÄ±r iÅŸlemlere zorlayacak olursak zaten kodumuz Ã§alÄ±ÅŸmayacaktÄ±r. SonuÃ§ olarak bizim bellek kullanÄ±mÄ±mÄ±zÄ± sÃ¼rekli kontrol altÄ±na almamÄ±z gerekiyor.
&nbsp;
&nbsp;

Eski programlama dillerinde bellek yÃ¶netimi otomatik olarak yapÄ±lmÄ±yordu ve kodu yazan kiÅŸinin bellekte ayÄ±rdÄ±ÄŸÄ± yer ile iÅŸi bittiÄŸi zaman temizlemesi gerekiyordu. Ancak modern diller ile bellek yÃ¶netimi otomatik hale getirildi ve artÄ±k ayrÄ±lan yere ihtiyaÃ§ duyulmayacaksa bellekten otomatik kaldÄ±rÄ±lÄ±yor. Bunun iÃ§in iki yÃ¶ntem anlatacaÄŸÄ±m: Garbage Collector ( Ã‡Ã¶p toplayÄ±cÄ±sÄ± ) ve Automatic Reference Counting ( Otomatik referans sayÄ±mÄ± )
&nbsp;
&nbsp;
&nbsp;

#### Garbage Collector:
&nbsp;
Bellekte uygulamanÄ±n kullandÄ±ÄŸÄ± alanlarÄ± Ã¼Ã§ parÃ§aya bÃ¶lerek bunlarÄ± kategorilendirir ve uygulama threadlerinin uygun olduÄŸu durumlarda tÃ¼m threadleri durdurarak temizleme iÅŸlemi gerÃ§ekleÅŸtirir. (1)
Bu yazÄ±da ARC konusuna odaklandÄ±ÄŸÄ±m iÃ§in kaynaklardaki yararlandÄ±ÄŸÄ±m link Ã¼zerinden Garbage Collector hakkÄ±nda ayrÄ±ntÄ±lara bakabilirsiniz.
&nbsp;
&nbsp;


#### Automatic Reference Counting
&nbsp;
Swift uygulamamÄ±zÄ±n Ã§alÄ±ÅŸma sÄ±rasÄ±nda bellek yÃ¶netimi iÃ§in ARC kullanÄ±r. Ä°ÅŸlem olarak Garbage Collector ile aynÄ± amacÄ± taÅŸÄ±maktadÄ±r artÄ±k kullanÄ±lmayan ayrÄ±lmÄ±ÅŸ bellek alanlarÄ±nÄ± temizlemek. Peki bunu neye gÃ¶re yapÄ±yor?
&nbsp;
Elimizde bir deÄŸiÅŸken olsun ve bu deÄŸiÅŸkene bir sÄ±nÄ±ftan nesne Ã¼retelim ve bunu bir fonksiyon iÃ§inde tanÄ±mlayalÄ±m. Fonksiyon iÃ§erisinde iÅŸlemlerimizi tamamladÄ±ÄŸÄ±mÄ±z zaman ARC artÄ±k bu nesneye ihtiyaÃ§ duyan kimse olmadÄ±ÄŸÄ± iÃ§in otomatik olarak temizleyecektir.
&nbsp;
Ã–rneÄŸin elimizde bir class olsun ve bu class'Ä± bir deÄŸiÅŸkende nesnesini oluÅŸturalÄ±m. ArdÄ±ndan oluÅŸturduÄŸumuz bu nesneyi farklÄ± bir deÄŸiÅŸkene daha verelim. Elimizde aynÄ± nesneyi referans eden iki adet deÄŸiÅŸkenimiz var. Ä°lk oluÅŸturduÄŸumuz deÄŸiÅŸkeni artÄ±k nil yapalÄ±m. Bu durumda nesnemizi deÄŸiÅŸkenimize verirken ARC ilk oluÅŸturma sÄ±rasÄ±nda 1 olarak saydÄ± ardÄ±ndan ikinci deÄŸiÅŸkene aynÄ± nesneyi verdiÄŸimiz iÃ§in ARC bu deÄŸeri 2 yaptÄ± son olarak ilk oluÅŸturduÄŸumuzu nil yaptÄ±k ARC bu sefer sayÄ±yÄ± bir azaltarak 1 olarak gÃ¼ncellendi. Bu durumda nesnemizi hala kaybetmedik. EÄŸer elimizdeki tek deÄŸiÅŸkeni de nil olarak eÅŸitlersek toplam referans sayÄ±sÄ± 0 olacak ve ARC temizleme iÅŸlemini yerine getirecek.
&nbsp;
&nbsp;
![](/upload-images/Swift-ARC/upload-008525674.png  width=100%)
&nbsp;
&nbsp;
Peki her ÅŸey bu kadar harika ÅŸekilde ilerliyor ve ARC bizim iÃ§in tÃ¼m iÅŸlerimizi zahmetsiz ÅŸekilde yerine getiriyor mu? Elbette hayÄ±r bizim dikkat etmemiz gereken ÅŸeyler de var.
&nbsp;
&nbsp;


#### Weak Referanslar
&nbsp;
Bunu anlatmak iÃ§in VIPER mimarisini Ã¶rnek vereceÄŸim. VIPER mimarisinde Presenter View'da gÃ¼ncelleme yapabilmesi iÃ§in View referansÄ±nÄ± tutmasÄ± gerekmektedir. AynÄ± zamanda View'da Presenter'a bazÄ± ÅŸeyler sÃ¶ylemeli ki aralarÄ±nda iletiÅŸim olsun. Bu durumda View'da Presenter'Ä±n referansÄ±nÄ± tutacaktÄ±r. Sanki bir Ã§Ä±kmaza giriyoruz, biraz daha bakalÄ±m. KullandÄ±ÄŸÄ±mÄ±z sayfada iÅŸimiz bitti kapattÄ±k. ARC kontrol edecek ve temizlemek isteyecektir ama View'u temizlemek iÃ§in Presenter'Ä±n temizlenmesi gerekiyor. Presenter'Ä± temizlemek istese bu sefer View'un temizlenmesi gerekiyor ki referans sayÄ±mÄ±z 0 olsun ve temizlenebilsin. Bir Ã§Ä±kmaza dÃ¼ÅŸtÃ¼k ve feransÄ±mÄ±z uygulama aÃ§Ä±k kalÄ±ncaya kadar yaÅŸayacak. Bunun Ã§Ã¶zÃ¼mÃ¼ iÃ§in oluÅŸturduÄŸumuz deÄŸiÅŸkene weak Ã¶n ekini veriyoruz. BÃ¶ylece ARC bunu saymayarak dÃ¶ngÃ¼ oluÅŸumunun Ã¶nÃ¼ne geÃ§iliyor. VIPER mimarisinde Presenter iÃ§inde bulunan View referansÄ±na weak vererek View denit edildiÄŸi sÄ±rada Presenter kolayca deinit yapÄ±labiliyor ve herhangi bir problem kalmÄ±yor.
&nbsp;

Bu yazÄ±yÄ± elbette unowned, strong ve bunlarÄ±n optional hallerini de dahil edip detaylandÄ±rmak mÃ¼mkÃ¼n ancak yazÄ±nÄ±n daha da uzamamasÄ± ve aÅŸaÄŸÄ±ya eklediÄŸim resmi Swift dokÃ¼manÄ±nda Ã§ok daha detaylÄ± bilgiler olduÄŸu iÃ§in eÄŸer ilginizi Ã§ekiyorsa aÅŸaÄŸÄ±dan ulaÅŸabilirsiniz.
&nbsp;
&nbsp;
OkuduÄŸunuz iÃ§in teÅŸekkÃ¼r ederim. EÄŸer bana sorularÄ±nÄ±z varsa link'ten bana ulaÅŸabilirsiniz, teÅŸekkÃ¼r ederim ğŸ™‚

1 = [https://medium.com/@gokhansengun/garbage-collector-nasÄ±l-Ã§alÄ±ÅŸÄ±r-3bdf2fb20282](https://medium.com/@gokhansengun/garbage-collector-nasÄ±l-Ã§alÄ±ÅŸÄ±r-3bdf2fb20282)

2 = [https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)
