<!DOCTYPE html><html lang="tr"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Yusuf Özgül | Blog | Resume | Portfolio"/><link rel="canonical" href="https://yusufozgul.com/blogs/observerPattern"/><meta name="twitter:url" content="https://yusufozgul.com/blogs/observerPattern"/><meta property="og:url" content="https://yusufozgul.com/blogs/observerPattern"/><title>Swift Observer Pattern | Yusuf Özgül | Blog | Resume | Portfolio</title><meta name="twitter:title" content="Swift Observer Pattern | Yusuf Özgül | Blog | Resume | Portfolio"/><meta property="og:title" content="Swift Observer Pattern | Yusuf Özgül | Blog | Resume | Portfolio"/><meta name="description" content="Bazı durumlarda oluşan bir olay ile istediğimiz yerin tetiklenmesi ve bir işlem yapması gerekebilir. Bu durumda nasıl yapabileceğimize bakalım."/><meta name="twitter:description" content="Bazı durumlarda oluşan bir olay ile istediğimiz yerin tetiklenmesi ve bir işlem yapması gerekebilir. Bu durumda nasıl yapabileceğimize bakalım."/><meta property="og:description" content="Bazı durumlarda oluşan bir olay ile istediğimiz yerin tetiklenmesi ve bir işlem yapması gerekebilir. Bu durumda nasıl yapabileceğimize bakalım."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="/gallery.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/upload-images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Yusuf Özgül | Blog | Resume | Portfolio"/><meta name="twitter:image" content="https://yusufozgul.com/upload-images/"/><meta property="og:image" content="https://yusufozgul.com/upload-images/"/></head><body class="main-wrapper"><header><link rel="stylesheet" href="/navigationStyle.css" type="text/css"/><nav class="header navBar"><div class="navArea"><input type="checkbox" id="check"/><label for="check"><img src="/upload-images/base/menu-icon.svg" width="30" height="30" class="checkbtn"/></label><label class="logo"><a href="/">Yusuf Özgül</a></label><ul class="navContent" id="hoverEnabled"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/contact">Contact</a></li><li><a href="/projects">Projects</a></li><li><a href="/blogs" class="active">Blog</a></li></ul></div></nav></header><div class="wrapper"><h2 class="post-title">Swift Observer Pattern</h2><a><p>September 11, 2020<br/>Reading 13 minutes</p></a><ul class="tag-list"><li class="swift"><a href="/tags/swift">Swift</a></li><li class="software"><a href="/tags/software">Software</a></li></ul><div class="post-description"><div><p>Observer'ın Türkçe karşılığı gözlemci olarak geçiyor. Kodlarımızda gözlemci ise neyi gözleyebilir? Bu sorunun bir çok cevabı olabilir örneğin bir değişkenimizde değişiklik yaparız ve değişkenimiz değiştiği zaman bir başka işlem tetiklenebilir. Başka bir örnek olarak arayüzde bir metin olsun ve bu metin bir başka sınıftan gelen verilere göre sürekli güncellensin. Observer pattern'i kurarak değişkeni istediğimiz yerden değiştirsek bile sadece değiştirmemiz yetsin. Bu yazı ile basit şekilde bir SwiftUI projesi yaparak observer pattern'i inceleyelim.</p><h4>Başlarken</h4><p>&nbsp; Her ne kadar bu yazıda SwiftUI vee Combine ikilisini kullanacak olsam da mevcut UIKit uygulamalarında değişkene verilecek <strong>didSet</strong> özelliği ya da <strong>Notification Center</strong> kullanarak yapılabilir. &nbsp;</p><pre><code><span class="keyword">var</span> value = <span class="number">0</span> {
    <span class="keyword">didSet</span> {
        <span class="call">print</span>(<span class="string">"Value changed, new value:</span> \(value)<span class="string">"</span>)
    }
}

value = <span class="number">10</span>
</code></pre><p>Örnekte görüldüğü gibi value değişkeni değiştirildiği zaman <strong>didSet</strong> çalışıp içerisine yazdıklarımızı gerçekleştirecek. &nbsp; &nbsp;</p><hr><h3>Başlıyoruz</h3><p>&nbsp;</p><p>SwiftUI ile gelen özellikler içerinde bu konuda işimize yarayacak iki <strong>property wrapper</strong> var. Bu <strong>property wrapper</strong> konusunda blog yazısı yazmayı planlıyorum ancak şimdilik kısaca bahsedeyim. <strong>Property wrapper</strong> bir değişkene ekstra özellikler katmamıza olanak sağlıyor. Değişken üzerinde yapılacak değişikliklerle ekstra özellikler katabiliyoruz. Şimdi bize hangileri lazım:</p><ul><li>ObservableObject</li><li>@Published</li><li>@ObservedObject</li></ul><p>ObservableObject aslında bir <strong>Property wrapper</strong> değil. O bir protokol. Biz hangi sınıfımızdaki değişiklikleri observe etmek istiyorsak bu sınıfımıza ObservableObject protokolünü implemente ederek observe edilebilirlik özelliğini kazandırıyoruz. &nbsp; @Published ise observe edilecek olan değişkenimiz yani bu değişkendeki değişiklikler sonrası aksiyon alınacak. &nbsp; Geldik sonuncusuna @ObservedObject bu bir sınıftan instance oluşturduğumuz zaman bu sınıfı observe et, değişiklikleri izle demiş oluyoruz. &nbsp; &nbsp; İlk olarak basit bir data class oluşturalım.</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">class</span> DataClass: <span class="type">ObservableObject</span> {
    <span class="keyword">@Published var</span> value = <span class="number">0</span>
    <span class="keyword">var</span> value2 = <span class="number">0</span>
    
    <span class="keyword">func</span> changeValue() {
        value = <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>...<span class="number">100</span>)
    }
    
    <span class="keyword">func</span> changeValue2() {
        value2 = <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>...<span class="number">100</span>)
    }
}
</code></pre><p>Özellikle incelemek için iki adet değişken ekledim biri @Published diğeri değil. Olay oldukça basit fonksiyonlar çağırılır ve değişkenler random olarak bir sayı alırlar.</p><p>&nbsp; &nbsp; Şimdi ise arayüz kodlarımızı inceleyim:</p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">@ObservedObject var</span> data = <span class="type">DataClass</span>()
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Spacer</span>()
            <span class="type">Text</span>(<span class="type">String</span>(data.<span class="property">value</span>))
            <span class="type">Text</span>(<span class="type">String</span>(data.<span class="property">value2</span>))
            <span class="type">Spacer</span>()
            <span class="type">Button</span>(<span class="string">"Change 1"</span>) {
                data.<span class="call">changeValue</span>()
            }
            <span class="type">Button</span>(<span class="string">"Change 2"</span>) {
                data.<span class="call">changeValue2</span>()
            }
            <span class="type">Spacer</span>()
        }
    }
}
</code></pre><p>Basit şekilde @ObservedObject ile DataClass'tan bir intance oluşturduk. Arayüzde bir VStack içerisinde İki adet text ve iki adet buton koyduk. Adım adım çalıştırıp neler oluyor bakalım: &nbsp; &nbsp; 1. Başlangıçta her ikisinden beklendiği gibi 0 olarak ekrana yazıldı. 2. <em>Change 1</em> butonuna bastığımız anda ilk metnimiz random bir değer ile değişti. 3. <em>Change 2</em> butonuna bastığımız anda ise ekranda herhangi bir değişiklik göremedik. 🤔 4. Tekrar <em>Change 1</em> butonuna bastığımız anda ise her iki metnimizin de değiştiğini gördük. 😯😯😯</p><p>&nbsp; &nbsp; Çıktıları inceleyelim. Beklendiği gibi <em>Change 1</em> butonu işlevini yerine getirdi. <em>value2</em> değişkeni @Published özelliğine sahip olmadığı için <em>Change 2</em> butonuna basmak pek bir anlam ifade etmedi. Ancak neden <em>Change 2</em> butonuna bastıktan sonra <em>Change 1</em> butonuna basınca ikinci metin değişti?</p><p>SwiftUI arayüz değişikliklerinde ilgili kısmı tekrar oluşturmak yerine arayüzün tamamını oluşturduğu için yeniden oluşturma sırasında <em>value2</em> değişkeninin değerini gidip tekrar okuması gerekti ve veriyi alırken güncellenmiş haliyle aldı bu sebeple güncellendi.</p><hr><p>&nbsp; &nbsp;</p><p>Bu yazımda kısaca Observer Pattern konusunu SwiftUI ile anlatmaya çalıştım. Bana sorularınız için <a href="/contact">iletişim</a> sayfasını kullanabilirsiniz, teşekkür ederim :)</p></div></div></div><footer><p><a href="https://github.com/johnsundell/publish">Generated using Publish</a></p><p><a href="/feed.rss">RSS feed</a></p><p><a href="https://github.com/yusufozgul">Developed Yusuf Özgül</a></p></footer></body></html>