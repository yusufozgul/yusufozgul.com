<!DOCTYPE html><html lang="tr"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Yusuf Özgül | Blog | Resume | Portfolio"/><link rel="canonical" href="https://yusufozgul.com/blogs/observerPattern2"/><meta name="twitter:url" content="https://yusufozgul.com/blogs/observerPattern2"/><meta name="og:url" content="https://yusufozgul.com/blogs/observerPattern2"/><title>Swift Observer Pattern - 2 | Yusuf Özgül | Blog | Resume | Portfolio</title><meta name="twitter:title" content="Swift Observer Pattern - 2 | Yusuf Özgül | Blog | Resume | Portfolio"/><meta name="og:title" content="Swift Observer Pattern - 2 | Yusuf Özgül | Blog | Resume | Portfolio"/><meta name="description" content="Bazı durumlarda oluşan bir olay ile istediğimiz yerin tetiklenmesi ve bir işlem yapması gerekebilir. Bu durumda nasıl yapabileceğimize bakalım."/><meta name="twitter:description" content="Bazı durumlarda oluşan bir olay ile istediğimiz yerin tetiklenmesi ve bir işlem yapması gerekebilir. Bu durumda nasıl yapabileceğimize bakalım."/><meta name="og:description" content="Bazı durumlarda oluşan bir olay ile istediğimiz yerin tetiklenmesi ve bir işlem yapması gerekebilir. Bu durumda nasıl yapabileceğimize bakalım."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="/gallery.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/upload-images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Yusuf Özgül | Blog | Resume | Portfolio"/><meta name="twitter:image" content="https://yusufozgul.com/upload-images/"/><meta name="og:image" content="https://yusufozgul.com/upload-images/"/></head><body class="main-wrapper"><header><link rel="stylesheet" href="/navigationStyle.css" type="text/css"/><nav class="header navBar"><div class="navArea"><input type="checkbox" id="check"/><label for="check"><img src="/upload-images/base/menu-icon.svg" width="30" height="30" class="checkbtn"/></label><label class="logo"><a href="/">Yusuf Özgül</a></label><ul class="navContent" id="hoverEnabled"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/contact">Contact</a></li><li><a href="/projects">Projects</a></li><li><a href="/blogs" class="active">Blog</a></li></ul></div></nav></header><div class="wrapper"><h2 class="post-title">Swift Observer Pattern - 2</h2><a><p>September 12, 2020<br/>Reading 10 minutes</p></a><ul class="tag-list"><li class="swift"><a href="/tags/swift">Swift</a></li><li class="software"><a href="/tags/software">Software</a></li></ul><div class="post-description"><div><p>Bir önceki yazımda SwiftUI ile Observer Pattern'in uygulamasını anlatmştım. Okumak isterseniz <a href="/blogs/observerPattern/">şu linki</a> kullanabilirsiniz. Bu yazımda ıse mevcut UIKit uygulamalarınızda Observer Pattern'i nasıl kullanabileceğinizi anlatacağım.</p><p>&nbsp; &nbsp;</p><h3>Başlayalım</h3><p>Burada izleyeceğimiz yaklaşım Notification Center ile değişiklerde uygulamamızı tetiklemek olacak. &nbsp;</p><pre><code><span class="keyword">class</span> DataManager {
    <span class="keyword">var</span> value = <span class="number">0</span> {
        <span class="keyword">didSet</span>{ <span class="call">updateState</span>() }
    }
    
    <span class="keyword">func</span> change() {
        value = <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">1</span>...<span class="number">100</span>)
    }
}

<span class="keyword">extension</span> <span class="type">DataManager</span> {
    <span class="keyword">internal func</span> updateState() {
    
    }
}
</code></pre><p>Basit şekilde bir sınıf ve bu sınıfa yazdığım extension bulunuyor. Value değişkenini değiştirmek için bir fonksiyon ve value her değiştiğinde çalışan bir fonksiyon daha var.</p><p>Şimdi bu sınıfımıza notification center eklemeliyiz.</p><pre><code><span class="keyword">class</span> DataManager {
    <span class="keyword">var</span> value = <span class="number">0</span> {
        <span class="keyword">didSet</span>{ <span class="call">updateState</span>() }
    }
    <span class="keyword">private let</span> notificationCenter: <span class="type">NotificationCenter</span>
    
    <span class="keyword">init</span>(notificationCenter: <span class="type">NotificationCenter</span> = .<span class="dotAccess">default</span>) {
        <span class="keyword">self</span>.<span class="property">notificationCenter</span> = notificationCenter
    }
    
    <span class="keyword">func</span> change() {
        value = <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">1</span>...<span class="number">100</span>)
    }
}

<span class="keyword">extension</span> <span class="type">Notification</span>.<span class="type">Name</span> {
    <span class="keyword">static var</span> valueChanged: <span class="type">Notification</span>.<span class="type">Name</span> {
        <span class="keyword">return</span> .<span class="keyword">init</span>(<span class="string">"DataManager.ValueChanged"</span>)
    }
}
</code></pre><p>Notification Center init fonsiyonunda ayarlandı ve çalışmaya hazır bekliyor. &gt; Uygulamanızda Notification Name gibi String ifadeleri sürekli elle vermek yerine extension ile tek bir yerden alabilirsiniz. Daha ileriye götürmek isterseniz bunları sınıfınıza göre enum'da toplayabilirsiniz.</p><pre><code><span class="keyword">extension</span> <span class="type">DataManager</span> {
    <span class="keyword">internal func</span> updateState() {
        notificationCenter.<span class="call">post</span>(name: .<span class="dotAccess">valueChanged</span>, object: value)
    }
}
</code></pre><p>Son olarak value değiştiğinde bir notification atacak şekilde güncelledik.</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
    <span class="keyword">@IBOutlet weak var</span> label: <span class="type">UILabel</span>!
    <span class="keyword">let</span> dataManager = <span class="type">DataManager</span>()

    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        label.<span class="property">text</span> = <span class="type">String</span>(dataManager.<span class="property">value</span>)
        <span class="call">addObserver</span>()
    }
    
    <span class="keyword">func</span> addObserver() {
        <span class="type">NotificationCenter</span>.<span class="property">default</span>.<span class="call">addObserver</span>(forName: .<span class="dotAccess">valueChanged</span>, object: <span class="keyword">nil</span>, queue: .<span class="dotAccess">main</span>) { [<span class="keyword">weak self</span>] (notification) <span class="keyword">in
            if let</span> value = notification.<span class="property">object</span> <span class="keyword">as</span>? <span class="type">Int</span> {
                <span class="keyword">self</span>?.<span class="property">label</span>.<span class="property">text</span> = <span class="type">String</span>(value)
            }
        }
    }
    
    <span class="keyword">@IBAction func</span> changeButton(<span class="keyword">_</span> sender: <span class="type">Any</span>) {
        dataManager.<span class="call">change</span>()
    }
}
</code></pre><p>StoryBoard kullanarak bir label ve bir buton tanımladım. Butona basıldğı zaman DataManager sınıfımızda bulunan change metodunu çalıştırıyor. addObserver fonksiyonu ise gönderdiğimiz notificationu dinlemek için. İçerisindeki object ile gönderdiğimiz veriyi alıp label'ı güncelledik. &nbsp; &nbsp; Peki bu <code>[weak self]</code> neyin nesi? Bunu ekleme sebebim memory leak denilen olayı önlemeye yönelik. Eğer <code>[weak self]</code> eklemeseydik observer self'i yani ViewController'ı sürekli elinde tutmak isteyecekti. ViewController deinit olması gerektiği zaman observer onu sıkı sıkıya tuttuğu için deinit olamayıp bellekte uyulama kapanana kadar kalacaktı. <code>[weak self]</code> ile bu bağlatıyı sıkı sıkıya yapmamıza gerek kalmadı. ViewController deinit olası gerektiği zaman onu tutan bir şey olmadığı için deinit olabildi ve ayrıca iOS 8 sonrasında ViewController deinit olduğu zaman observer'da dinlemeyi otomatik olarak bıraktı. Bu şekilde memory leak olmadı. &nbsp;</p><hr><p>&nbsp; &nbsp; Bu yazımda kısaca Observer Pattern konusunu UIKit ve Notification Center ile anlatmaya çalıştım. Bana sorularınız için <a href=""/contact"">iletişim</a> sayfasını kullanabilirsiniz, teşekkür ederim :)</p></div></div></div><footer><p><a href="https://github.com/johnsundell/publish">Generated using Publish</a></p><p><a href="/feed.rss">RSS feed</a></p><p><a href="https://github.com/yusufozgul">Developed Yusuf Özgül</a></p></footer></body></html>